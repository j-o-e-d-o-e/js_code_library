function

definitve, ch.8/eloquent, p.40ff.

three notations to define as
    (1) a declaration
        - declares a variable whose value is the func itself
        - can be called before declaration (not top-to-bottom control-flow)
    (2) an expression
        - does not declare automatically a variable
        - func name is optional
        - assign the newly defined func-obj to a constant if you are going to need to refer to it multiple times
        - cannot be invoked before they are defined
    (3) an arrow function
        - if body is a single return-statement, the return-keyword, semicolon and curly braces can be omitted
            - if expression to be returned is additionally an obj-literal, put the obj-literal inside parentheses
        - when only one parameter, parentheses can be omitted
        - if no parameters, parameter list is just an empty set of parentheses
        - inherit the value of 'this' from the environment in which they are defined
        - commonly used for anonymous functions passed to another func as arg
        - since ES/JS 2015 (ES6)

JS funcs are objs. Therefore, they
    - have methods
        - call() and apply() invoke the func indirectly
            - allow to explicitly specify the 'this'-value for the invocation, i.e. you can invoke any func as a method of an obj (even if it's not)
            - 1st arg: obj on which the func is to be invoked
            - 2nd arg: for call(), multiple values; for apply(), array of values
        - bind() binds a func to an obj (4)
            - most common use to make non-arrow funcs behave like arrow-funcs
    - can be assigned to variables
        - funcs can be stored in props of objects or elems of an array, passed as args to a func, etc.
    - can have (static) properties (5)
        - length: the number of params
        - name: name when defined

JS funcs are executed using the scope they are defined in (6)

EXAMPLE
(1)
console.log(distance(...[1, 1, 5, 4])); // 5

function distance(x1, y1, x2, y2) {
    let dx = x2 - x1;
    let dy = y2 - y1;
    return Math.sqrt(dx * dx + dy * dy);
}
(2)
const square = function (x) {
    return x * x;
};
console.log(square(3)); // 9
(3)
const sum = (x, y) => x + y;
sum(1,2); // 3

let filtered = [1,null,2,3].filter(x => x !== null); // [ 1, 2, 3 ]
(4)
function func(y) {
    return this.x + y;
}
let obj = {x: 1};
let f = func.bind(obj);
console.log(f(2)); // => 3
(5)
uniqueInt.counter = 0;
function uniqueInt() {
    return uniqueInt.counter++;
}
console.log(uniqueInt()); // => 0
console.log(uniqueInt()); // => 1
(6)
function counter() {
    let n = 0;
    return {
        count() {
            return ++n;
        },
        reset: function () {
            n = 0;
        }
    };
}
let c = counter();
c.count();
console.log(c.count()); // => 2
c.reset();
console.log(c.count()) // => 1
